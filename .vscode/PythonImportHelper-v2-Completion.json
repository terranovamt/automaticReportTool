[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "fileinput",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fileinput",
        "description": "fileinput",
        "detail": "fileinput",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "jupiter.utility",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jupiter.utility",
        "description": "jupiter.utility",
        "detail": "jupiter.utility",
        "documentation": {}
    },
    {
        "label": "rework_stdf",
        "importPath": "rework_stdf",
        "description": "rework_stdf",
        "isExtraImport": true,
        "detail": "rework_stdf",
        "documentation": {}
    },
    {
        "label": "condition_rework",
        "importPath": "condition",
        "description": "condition",
        "isExtraImport": true,
        "detail": "condition",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "core",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "core",
        "description": "core",
        "detail": "core",
        "documentation": {}
    },
    {
        "label": "stdf2csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stdf2csv",
        "description": "stdf2csv",
        "detail": "stdf2csv",
        "documentation": {}
    },
    {
        "label": "shmoo",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shmoo",
        "description": "shmoo",
        "detail": "shmoo",
        "documentation": {}
    },
    {
        "label": "BaseRotatingHandler",
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "isExtraImport": true,
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "read_csv_with_fallback",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def read_csv_with_fallback(path):\n    import pandas as pd\n    from pandas.errors import EmptyDataError, ParserError\n    import os\n    try:\n        # print (os.path.abspath(path))\n        return pd.read_csv(os.path.abspath(path))\n    except (EmptyDataError, FileNotFoundError, ParserError) as e:\n        # print(\"ERROR:\", e)\n        return pd.DataFrame()",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "color_cpk",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def color_cpk(val):\n    try:\n        val = float(val)\n    except ValueError:\n        return \"\"\n    if isinstance(val, (int, float)):\n        if val < 1.2:\n            return \"background-color: #F23202\"\n        elif 1.2 <= val < 1.3:\n            return \"background-color: #E85D04\"",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "color_yield",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def color_yield(val):\n    try:\n        val = float(val.strip(\"%\"))\n    except ValueError:\n        return \"\"\n    if isinstance(val, (int, float)):\n        if val < 50:\n            return \"background-color: #F23202\"\n        elif 50 <= val < 60:\n            return \"background-color: #E85D04\"",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "color_kurtosis",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def color_kurtosis(val):\n    try:\n        val = float(val)\n    except ValueError:\n        return \"\"\n    if isinstance(val, (int, float)):\n        if val > -0.2:\n            return \"background-color: #F23202\"\n        elif -0.2 >= val > -0.4:\n            return \"background-color: #E85D04\"",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "color_cp",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def color_cp(val):\n    try:\n        val = float(val)\n    except ValueError:\n        return \"\"\n    if isinstance(val, (int, float)):\n        if val < 6:\n            return \"background-color: #F23202\"\n        elif 6 <= val < 7:\n            return \"background-color: #E85D04\"",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "power_of_10",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def power_of_10(value):\n    if value >= 0:\n        return 10**value\n    else:\n        return 1 / (10 ** abs(value))\ndef find_value(value, calc_type):\n    if value == 0:\n        if calc_type == \"min\":\n            min_value = -0.01\n            # print(f\"Valore attuale: {value} Minimo: {min_value}\")",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "find_value",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def find_value(value, calc_type):\n    if value == 0:\n        if calc_type == \"min\":\n            min_value = -0.01\n            # print(f\"Valore attuale: {value} Minimo: {min_value}\")\n            return 0.01\n        elif calc_type == \"max\":\n            max_value = 0.01\n            # print(f\"Valore attuale: {value} Massimo: {max_value}\")\n            return -0.01",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "write_log",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def write_log(message, filename=\"../run.log\"):\n    import os\n    import datetime\n    now = datetime.datetime.now()\n    timestamp = now.strftime(\"[%Y-%m-%d %H:%M:%S]\")\n    try:\n        with open(filename, \"r+\") as file:\n            content = file.readlines()\n            # Limit the content to the last 499 lines\n            if len(content) >= 500:",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "interpolate_color",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def interpolate_color(color1, color2, factor: float):\n    \"\"\"Interpolates between two colors.\"\"\"\n    return [color1[i] + (color2[i] - color1[i]) * factor for i in range(3)]\ndef hex_to_rgb(hex_color: str):\n    \"\"\"Converts a hex color to an RGB tuple.\"\"\"\n    hex_color = hex_color.lstrip(\"#\")\n    return tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))\ndef rgb_to_hex(rgb_color):\n    \"\"\"Converts an RGB tuple to a hex color.\"\"\"\n    return \"#{:02x}{:02x}{:02x}\".format(",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "hex_to_rgb",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def hex_to_rgb(hex_color: str):\n    \"\"\"Converts a hex color to an RGB tuple.\"\"\"\n    hex_color = hex_color.lstrip(\"#\")\n    return tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))\ndef rgb_to_hex(rgb_color):\n    \"\"\"Converts an RGB tuple to a hex color.\"\"\"\n    return \"#{:02x}{:02x}{:02x}\".format(\n        int(rgb_color[0]), int(rgb_color[1]), int(rgb_color[2])\n    )\ndef create_gradient(colors, num_colors):",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "rgb_to_hex",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def rgb_to_hex(rgb_color):\n    \"\"\"Converts an RGB tuple to a hex color.\"\"\"\n    return \"#{:02x}{:02x}{:02x}\".format(\n        int(rgb_color[0]), int(rgb_color[1]), int(rgb_color[2])\n    )\ndef create_gradient(colors, num_colors):\n    \"\"\"Creates a gradient of colors.\"\"\"\n    gradient = []\n    num_segments = len(colors) - 1\n    colors_per_segment = num_colors // num_segments",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "create_gradient",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def create_gradient(colors, num_colors):\n    \"\"\"Creates a gradient of colors.\"\"\"\n    gradient = []\n    num_segments = len(colors) - 1\n    colors_per_segment = num_colors // num_segments\n    for i in range(num_segments):\n        color1 = hex_to_rgb(colors[i])\n        color2 = hex_to_rgb(colors[i + 1])\n        for j in range(colors_per_segment):\n            factor = j / float(colors_per_segment)",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "create_heatmap",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def create_heatmap(td, gradientcolor, xwafer, ywafer):\n    import numpy as np\n    import pandas as pd\n    import plotly.graph_objects as go\n    std_dev = np.std(td[\"Value\"])\n    step = std_dev / 10\n    if step < 1e-5:\n        step = std_dev\n    additional_data = pd.DataFrame(\n        {",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "freedman_diaconis_rule",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def freedman_diaconis_rule(data):\n    import numpy as np\n    data = data.dropna()  # Rimuove NaN\n    data = data[np.isfinite(data)]  # Rimuove inf e -inf\n    q25, q75 = np.percentile(data, [1, 99])  # Calcolo IQR\n    iqr = q75 - q25\n    if iqr == 0:\n        return 10\n    n = len(data)\n    bin_width = 2 * iqr / np.cbrt(n)",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "create_histogram",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def create_histogram(td, units, ul, ll, maxvalue, minvalue, tempSTcolort, STred):\n    import plotly_express as px\n    nbins_fd = freedman_diaconis_rule(td[\"Value\"])\n    fig = px.histogram(\n        td[[\"Value\", \"XId\", \"YId\"]],\n        x=\"Value\",\n        nbins=nbins_fd,\n        marginal=\"box\",\n        hover_data=td[[\"Value\", \"XId\", \"YId\"]],\n        barmode=\"overlay\",",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "create_histogram_with_color",
        "kind": 2,
        "importPath": "src.jupiter.utility",
        "description": "src.jupiter.utility",
        "peekOfCode": "def create_histogram_with_color(\n    td, units, ul, ll, maxvalue, minvalue, tempSTcolort, STred\n):\n    import plotly_express as px\n    fig = px.histogram(\n        td[[\"Value\", \"XId\", \"YId\", \"Volt\"]],\n        x=\"Value\",\n        color=\"Volt\",\n        marginal=\"box\",\n        hover_data=td[[\"Value\", \"XId\", \"YId\"]],",
        "detail": "src.jupiter.utility",
        "documentation": {}
    },
    {
        "label": "detect_file_type",
        "kind": 2,
        "importPath": "src.condition",
        "description": "src.condition",
        "peekOfCode": "def detect_file_type(file_path):\n    \"\"\"Rileva il tipo di file basandosi sull'estensione\"\"\"\n    if file_path.lower().endswith('.html'):\n        return 'html'\n    elif file_path.lower().endswith('.csv'):\n        return 'csv'\n    else:\n        raise ValueError(f\"Tipo di file non supportato: {file_path}\")\ndef detect_separator(file_path, max_lines=10):\n    \"\"\"Rileva il separatore CSV (, o ;)\"\"\"",
        "detail": "src.condition",
        "documentation": {}
    },
    {
        "label": "detect_separator",
        "kind": 2,
        "importPath": "src.condition",
        "description": "src.condition",
        "peekOfCode": "def detect_separator(file_path, max_lines=10):\n    \"\"\"Rileva il separatore CSV (, o ;)\"\"\"\n    with open(file_path, \"r\", encoding=\"utf-8\") as file:\n        for line_number in range(max_lines):\n            line = file.readline()\n            if not line:\n                break\n            # Conta le occorrenze di virgole e punti e virgola\n            comma_count = line.count(',')\n            semicolon_count = line.count(';')",
        "detail": "src.condition",
        "documentation": {}
    },
    {
        "label": "read_html_to_dataframe",
        "kind": 2,
        "importPath": "src.condition",
        "description": "src.condition",
        "peekOfCode": "def read_html_to_dataframe(file_path):\n    \"\"\"Legge un file HTML e converte le tabelle in DataFrame\"\"\"\n    try:\n        # Prova prima con pandas read_html\n        tables = pd.read_html(file_path, encoding='utf-8')\n        if tables:\n            # Prendi la prima tabella trovata\n            df = tables[0]\n            return df\n    except Exception as e:",
        "detail": "src.condition",
        "documentation": {}
    },
    {
        "label": "read_csv_to_dataframe",
        "kind": 2,
        "importPath": "src.condition",
        "description": "src.condition",
        "peekOfCode": "def read_csv_to_dataframe(file_path):\n    \"\"\"Legge un file CSV con rilevamento automatico del separatore\"\"\"\n    separator, header_line = detect_separator(file_path)\n    try:\n        df = pd.read_csv(file_path, sep=separator, header=header_line, encoding='utf-8')\n    except UnicodeDecodeError:\n        # Prova con encoding alternativo\n        df = pd.read_csv(file_path, sep=separator, header=header_line, encoding='latin-1')\n    return df\ndef read_file_to_dataframe(file_path):",
        "detail": "src.condition",
        "documentation": {}
    },
    {
        "label": "read_file_to_dataframe",
        "kind": 2,
        "importPath": "src.condition",
        "description": "src.condition",
        "peekOfCode": "def read_file_to_dataframe(file_path):\n    \"\"\"Funzione principale per leggere qualsiasi tipo di file supportato\"\"\"\n    file_type = detect_file_type(file_path)\n    if file_type == 'html':\n        return read_html_to_dataframe(file_path)\n    elif file_type == 'csv':\n        return read_csv_to_dataframe(file_path)\n    else:\n        raise ValueError(f\"Tipo di file non supportato: {file_type}\")\ndef condition_rework(parameter, directory_path):",
        "detail": "src.condition",
        "documentation": {}
    },
    {
        "label": "condition_rework",
        "kind": 2,
        "importPath": "src.condition",
        "description": "src.condition",
        "peekOfCode": "def condition_rework(parameter, directory_path):\n    \"\"\"Elabora i file e crea condition.csv\"\"\"\n    # Determina il file da processare\n    if os.path.isdir(directory_path):\n        # Se è una directory, cerca file CSV o HTML\n        file_path = None\n        for filename in os.listdir(directory_path):\n            if filename.lower().endswith(('.csv', '.html')):\n                file_path = os.path.join(directory_path, filename)\n                break",
        "detail": "src.condition",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.condition",
        "description": "src.condition",
        "peekOfCode": "def main():\n    parameter = {\n        \"TITLE\": \"MBIST\",\n        \"COM\": \"mbist\",\n        \"FLOW\": \"EWS1\",\n        \"TYPE\": \"STD\",\n        \"PRODUCT\": \"Mosquito512K\",\n        \"CODE\": \"44E\",\n        \"LOT\": \"P6AX86\",\n        \"WAFER\": \"1\",",
        "detail": "src.condition",
        "documentation": {}
    },
    {
        "label": "process_composite",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def process_composite(parameter, csv_name,df_stdf):\n    \"\"\"\n    Process the composite data from a CSV file and execute the report generation.\n    Args:\n        parameter (dict): Parameters for processing.\n        csv_name (str): CSV file name to process.\n    \"\"\"\n    try:\n        tsr = pd.read_csv(os.path.abspath(f\"{csv_name}.tsr.csv\"))\n        if str(parameter[\"COM\"]).upper() == \"TTIME\":",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "process_condition",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def process_condition(parameter, stdf_folder,df_stdf):\n    \"\"\"\n    Process a FAKE composite for condition report and execute generation.\n    Args:\n        parameter (dict): Parameters for processing.\n        tsr (DataFrame): DataFrame containing test results.\n        composite (str): Composite name to process.\n        csv_file (str): CSV file name to process.\n    \"\"\"\n    uty.write_log(f\"Converting ANAFLOW by COM\", FILENAME)",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "process_yield",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def process_yield(parameter, tsr, composite, csv_file, df_stdf):\n    \"\"\"\n    Process a FAKE composite for yeald analysis and execute the report generation.\n    Args:\n        parameter (dict): Parameters for processing.\n        tsr (DataFrame): DataFrame containing test results.\n        composite (str): Composite name to process.\n        csv_file (str): CSV file name to process.\n    \"\"\"\n    if parameter[\"TYPE\"].upper() == \"X30\":",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "process_ttime",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def process_ttime(parameter, tsr, composite, csv_file,df_stdf):\n    \"\"\"\n    Process a FAKE composite for test time analysis and execute the report generation.\n    Args:\n        parameter (dict): Parameters for processing.\n        tsr (DataFrame): DataFrame containing test results.\n        composite (str): Composite name to process.\n        csv_file (str): CSV file name to process.\n    \"\"\"\n    match_group = tsr[\"TEST_NAM\"].str.extract(r\"(log_ttime.*)\".format(composite))",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "process_single_composite",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def process_single_composite(\n    parameter, tsr, composite, csv_file,df_stdf):\n    \"\"\"\n    Process a single composite and execute the report generation.\n    Args:\n        parameter (dict): Parameters for processing.\n        tsr (DataFrame): DataFrame containing test results.\n        composite (str): Composite name to process.\n        csv_file (str): CSV file name to process.\n    \"\"\"",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "write_config_file",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def write_config_file(parameter):\n    \"\"\"\n    Write the configuration parameters to a JSON file.\n    Args:\n        parameter (dict): Parameters for processing.\n    \"\"\"\n    cfgfile = f\"./src/jupiter/cfg.json\"\n    try:\n        # Convert any Series objects in the parameter dictionary to lists\n        parameter = {",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "convert_notebook_to_html",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def convert_notebook_to_html(parameter):\n    \"\"\"\n    Convert the Jupyter notebook to HTML format.\n    Args:\n        parameter (dict): Parameters for processing.\n    \"\"\"\n    uty.write_log(\"Start Jupyter conversion\", FILENAME)\n    timestartsub = datetime.datetime.now()\n    str_output = (\n        parameter[\"TITLE\"]",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "rework_report",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def rework_report(parameter, dir_output, str_output):\n    \"\"\"\n    Substitute HTML title with TITLE name and add CSS for better report aspect.\n    Args:\n        parameter (dict): Parameters for processing.\n    \"\"\"\n    report_path = os.path.abspath(f\"{dir_output}/{str_output}.html\")\n    title = parameter[\"TITLE\"]\n    new_str = (\n        \"<title>\"",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "exec",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def exec(parameter,df_stdf):\n    \"\"\"\n    Execute the report generation steps.\n    Args:\n        parameter (dict): Parameters for processing.\n    \"\"\"\n    try:\n        if (\n            str(parameter[\"COM\"].upper()) == \"YIELD\"\n            or str(parameter[\"TYPE\"]).upper() == \"CONDITION\"",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "post_exec",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def post_exec(parameter, timestartsub, dir_output, str_output):\n    \"\"\"\n    Post-execution function to handle final steps.\n    Args:\n        parameter (dict): Parameters for processing.\n    \"\"\"\n    uty.write_log(\"postexec START\", FILENAME)\n    # rework_report(parameter, dir_output, str_output)\n    uty.write_log(\"postexec DONE\", FILENAME)\n    timeendsub = datetime.datetime.now()",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "resetpost",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def resetpost(file_path):\n    print(\"Reset post.json\")\n    with open(file_path, \"r\") as file:\n        data = json.load(file)\n    for item in data[\"data\"]:\n        item[\"Run\"] = \"0\"\n    with open(file_path, \"w\") as file:\n        json.dump(data, file, indent=4)\ndef get_parameter(path):\n    product, productcut, flow, lot_pkg, waf_badge, mytype, stdname = path.split(\"\\\\\",10)[4:]",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "get_parameter",
        "kind": 2,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "def get_parameter(path):\n    product, productcut, flow, lot_pkg, waf_badge, mytype, stdname = path.split(\"\\\\\",10)[4:]\n    # product,productcut, flow, lot_pkg, waf_badge, mytype, stdname = path.split(\"/\")[3:]\n    lot_pkg, waf_badge, corner = (waf_badge + \"_TTTT\").split(\"_\", 2)\n    parameter = {\n        \"TITLE\": \"\",\n        \"COM\": \"\",\n        \"FLOW\": flow.upper(),\n        \"TYPE\": mytype.upper(),\n        \"PRODUCT\": \"\",",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "src.core",
        "description": "src.core",
        "peekOfCode": "FILENAME = os.path.abspath(\"src/run.log\")\ndef process_composite(parameter, csv_name,df_stdf):\n    \"\"\"\n    Process the composite data from a CSV file and execute the report generation.\n    Args:\n        parameter (dict): Parameters for processing.\n        csv_name (str): CSV file name to process.\n    \"\"\"\n    try:\n        tsr = pd.read_csv(os.path.abspath(f\"{csv_name}.tsr.csv\"))",
        "detail": "src.core",
        "documentation": {}
    },
    {
        "label": "ProcessType",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class ProcessType(Enum):\n    \"\"\"Enumeration for different processing types.\"\"\"\n    STDF2CSV = \"stdf2csv\"\n    CSV2REPORT = \"csv2report\"\n    CONDITION2REPORT = \"condition2report\"\n    SHMOO = \"shmoo\"\nclass FileType(Enum):\n    \"\"\"Enumeration for file types.\"\"\"\n    STDF = \"stdf\"\n    CSV = \"csv\"",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "FileType",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class FileType(Enum):\n    \"\"\"Enumeration for file types.\"\"\"\n    STDF = \"stdf\"\n    CSV = \"csv\"\n    CONDITION = \"condition\"\n    SHMOO = \"shmoo\"\n@dataclass\nclass ProcessingConfig:\n    \"\"\"Configuration for processing operations.\"\"\"\n    allowed_flow = {\"EWS1\", \"EWS2\", \"EWS3\", \"EWSDIE\", \"FT\", \"FT1\", \"FT2\", \"FIAB\", \"QC\", \"FA\"}",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "ProcessingConfig",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class ProcessingConfig:\n    \"\"\"Configuration for processing operations.\"\"\"\n    allowed_flow = {\"EWS1\", \"EWS2\", \"EWS3\", \"EWSDIE\", \"FT\", \"FT1\", \"FT2\", \"FIAB\", \"QC\", \"FA\"}\n    allowed_package = {\"QFP\", \"QFN\", \"DIP\", \"WLCSP\", \"CSP\"}\n    product_regex = re.compile(r\"^[A-F0-9]{3}$\")\n    max_lines_per_log = 1000\n    backup_count = 1\n# ==================================================\n# Logging Configuration\n# ==================================================",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "LineCountRotatingFileHandler",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class LineCountRotatingFileHandler(BaseRotatingHandler):\n    \"\"\"\n    Custom rotating file handler that rotates log files based on line count\n    instead of file size.\n    \"\"\"\n    def __init__(self, filename, max_lines=1000, backup_count=1, **kwargs):\n        \"\"\"\n        Initialize the handler.\n        Args:\n            filename (str): Path to the log file",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "ParameterExtractor",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class ParameterExtractor:\n    \"\"\"Handles parameter extraction from file paths.\"\"\"\n    @staticmethod\n    def get_parameter_from_stdf_path(path: str) -> Dict:\n        \"\"\"\n        Extract parameters from STDF file path.\n        Args:\n            path: STDF file path to parse\n        Returns:\n            Dictionary containing extracted parameters",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "CompositeManager",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class CompositeManager:\n    \"\"\"Handles composite list retrieval and validation.\"\"\"\n    @staticmethod\n    def get_composite_list(logger: logging.Logger, svn_url: str) -> List[str]:\n        \"\"\"\n        Retrieve composite list from SVN repository.\n        Args:\n            logger: Logger instance\n            svn_url: SVN repository URL\n        Returns:",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "FileProcessor",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class FileProcessor:\n    \"\"\"Handles file processing operations.\"\"\"\n    @staticmethod\n    def check_completion_marker(path: str, marker_name: str) -> bool:\n        \"\"\"\n        Check if completion marker file exists.\n        Args:\n            path: Directory path to check\n            marker_name: Name of marker file\n        Returns:",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "DirectoryPoller",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class DirectoryPoller:\n    \"\"\"Handles directory polling for new files.\"\"\"\n    def __init__(self, config: ProcessingConfig):\n        self.config = config\n    def check_condition_files(self, folder_path: str, condition_list: List[str]) -> bool:\n        \"\"\"\n        Check if folder contains a CONDITION subdirectory with anaflow files and add them to condition list.\n        Args:\n            folder_path: Path to flow folder (e.g., EWS1, EWS2, FT, etc.)\n            condition_list: List to append found file paths",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "ProcessingWorker",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class ProcessingWorker:\n    \"\"\"Base class for processing workers.\"\"\"\n    def __init__(self, process_type: ProcessType):\n        self.process_type = process_type\n    def create_title(self, parameter: Dict, composite: str) -> str:\n        \"\"\"Create title based on process type and parameters.\"\"\"\n        if self.process_type == ProcessType.CONDITION2REPORT:\n            return f\"{composite.upper().replace('_', ' ')} {parameter['FLOW'].upper()} condition\"\n        else:\n            return f\"{composite.upper().replace('_', ' ')} {parameter['FLOW'].upper()} {parameter['TYPE'].lower()}\"",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "ReportWorker",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class ReportWorker(ProcessingWorker):\n    \"\"\"Worker for report generation (CSV2REPORT and CONDITION2REPORT).\"\"\"\n    def process_file(self, path: str, logger: logging.Logger):\n        \"\"\"\n        Main processing function for condition report generation.\n        Updated to handle CONDITION subdirectory structure.\n        Args:\n            path: Path to condition file to process\n            logger: Logger instance\n        \"\"\"",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "STDFWorker",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class STDFWorker(ProcessingWorker):\n    \"\"\"Worker for STDF to CSV conversion.\"\"\"\n    def __init__(self):\n        super().__init__(ProcessType.STDF2CSV)\n    def process_file(self, path: str, logger: logging.Logger):\n        \"\"\"\n        Convert STDF file to CSV format.\n        Args:\n            path: Path to STDF file\n            logger: Logger instance",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "ShmooWorker",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class ShmooWorker(ProcessingWorker):\n    \"\"\"Worker for SHMOO processing.\"\"\"\n    def __init__(self):\n        super().__init__(ProcessType.SHMOO)\n    def process_file(self, directory_path: str, logger: logging.Logger):\n        \"\"\"\n        Process SHMOO directory.\n        Args:\n            directory_path: Path to SHMOO directory\n            logger: Logger instance",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "STDFProcessingSystem",
        "kind": 6,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "class STDFProcessingSystem:\n    \"\"\"Main processing system that coordinates all operations.\"\"\"\n    def __init__(self, watch_path: str):\n        \"\"\"\n        Initialize the STDF processing system.\n        Args:\n            watch_path: Root directory to monitor for files\n        \"\"\"\n        self.watch_path = watch_path\n        self.config = ProcessingConfig()",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "def setup_logger(name: str, log_file: str, level: int = logging.INFO) -> logging.Logger:\n    \"\"\"\n    Set up a logger with custom rotating file handler.\n    Args:\n        name: Logger name\n        log_file: Path to log file\n        level: Logging level\n    Returns:\n        Configured logger instance\n    \"\"\"",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.pollingv4",
        "description": "src.pollingv4",
        "peekOfCode": "def main():\n    \"\"\"Main execution function.\"\"\"\n    # Set watch path\n    watch_path = r\"\\\\gpm-pe-data.gnb.st.com\\ENGI_MCD_STDF\"\n    # Alternative path for Unix systems: watch_path = \"/prj/ENGI_MCD_STDF\"\n    # Create and run the processing system\n    processing_system = STDFProcessingSystem(watch_path)\n    try:\n        processing_system.run_continuous()\n    except Exception as e:",
        "detail": "src.pollingv4",
        "documentation": {}
    },
    {
        "label": "power_of_10",
        "kind": 2,
        "importPath": "src.rework_stdf",
        "description": "src.rework_stdf",
        "peekOfCode": "def power_of_10(value):\n    if value >= 0:\n        return 10**value\n    else:\n        return 1 / (10 ** abs(value))\ndef find_value(value, calc_type):\n    if value == 0:\n        if calc_type == \"min\":\n            min_value = -0.1\n            # print(f\"Valore attuale: {value} Minimo: {min_value}\")",
        "detail": "src.rework_stdf",
        "documentation": {}
    },
    {
        "label": "find_value",
        "kind": 2,
        "importPath": "src.rework_stdf",
        "description": "src.rework_stdf",
        "peekOfCode": "def find_value(value, calc_type):\n    if value == 0:\n        if calc_type == \"min\":\n            min_value = -0.1\n            # print(f\"Valore attuale: {value} Minimo: {min_value}\")\n            return 0.1\n        elif calc_type == \"max\":\n            max_value = 0.1\n            # print(f\"Valore attuale: {value} Massimo: {max_value}\")\n            return -0.1",
        "detail": "src.rework_stdf",
        "documentation": {}
    },
    {
        "label": "rework_stdf",
        "kind": 2,
        "importPath": "src.rework_stdf",
        "description": "src.rework_stdf",
        "peekOfCode": "def rework_stdf(parameter,df_stdf):\n    # print(parameter)\n    composite = parameter[\"COM\"]\n    flwtp = parameter[\"TYPE\"]\n    groosgood30 = 0\n    p = os.listdir()\n    ptr = pd.DataFrame()\n    ftr = pd.DataFrame()\n    population = pd.DataFrame()\n    ptr_dict = {}",
        "detail": "src.rework_stdf",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.rework_stdf",
        "description": "src.rework_stdf",
        "peekOfCode": "def main():\n    import json\n    parameter = {\n        \"TITLE\": \"MBIST\",\n        \"COM\": \"mbist\",\n        \"FLOW\": \"EWS\",\n        \"TYPE\": \"STD\",\n        \"PRODUCT\": \"Mosquito\",\n        \"CODE\": \"44E\",\n        \"LOT\": \"P6AX86\",",
        "detail": "src.rework_stdf",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 5,
        "importPath": "src.rework_stdf",
        "description": "src.rework_stdf",
        "peekOfCode": "debug = False\nFILENAME = os.path.abspath(\"src/run.log\")\ndef power_of_10(value):\n    if value >= 0:\n        return 10**value\n    else:\n        return 1 / (10 ** abs(value))\ndef find_value(value, calc_type):\n    if value == 0:\n        if calc_type == \"min\":",
        "detail": "src.rework_stdf",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "src.rework_stdf",
        "description": "src.rework_stdf",
        "peekOfCode": "FILENAME = os.path.abspath(\"src/run.log\")\ndef power_of_10(value):\n    if value >= 0:\n        return 10**value\n    else:\n        return 1 / (10 ** abs(value))\ndef find_value(value, calc_type):\n    if value == 0:\n        if calc_type == \"min\":\n            min_value = -0.1",
        "detail": "src.rework_stdf",
        "documentation": {}
    },
    {
        "label": "ShmooVisualizer",
        "kind": 6,
        "importPath": "src.shmoo",
        "description": "src.shmoo",
        "peekOfCode": "class ShmooVisualizer:\n    def __init__(self, debug=False):\n        self.debug = debug\n        self._progress_lock = threading.Lock()\n        self._last_progress_time = 0\n    def _show_progress(self, current: int, total: int, start_time: float, phase: str = \"Processing\"):\n        \"\"\"Show progress bar with percentage and performance metrics\"\"\"\n        current_time = time.time()\n        # Update only every 0.1 seconds to avoid performance impact\n        if current_time - self._last_progress_time < 0.1 and current < total:",
        "detail": "src.shmoo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.shmoo",
        "description": "src.shmoo",
        "peekOfCode": "def main():\n    \"\"\"Main function with debug argument support\"\"\"\n    parser = argparse.ArgumentParser(description='Optimized Shmoo Data Visualizer - Aggregated Plots Only')\n    parser.add_argument('directory', nargs='?', default='.', \n                       help='Directory containing .shm files (default: current directory)')\n    parser.add_argument('--debug', action='store_true', default=False,\n                       help='Enable debug output (default: False)')\n    args = parser.parse_args()\n    print(\"=== Shmoo Data Visualizer ===\")\n    print(f\"Directory: {os.path.abspath(args.directory)}\")",
        "detail": "src.shmoo",
        "documentation": {}
    },
    {
        "label": "rename_files",
        "kind": 2,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "def rename_files(folder, old_ext, new_ext):\n    uty.write_log(f\"Rename .csv\", FILENAME)\n    if not os.path.exists(folder):\n        print(f\"Error: The folder {folder} does not exist.\")\n        return []\n    renamed_files = []\n    for filename in os.listdir(folder):\n        if filename.endswith(old_ext):\n            base = os.path.splitext(filename)[0]\n            new_name = f\"{base}{new_ext}\"",
        "detail": "src.stdf2csv",
        "documentation": {}
    },
    {
        "label": "convert_files",
        "kind": 2,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "def convert_files(folder, hex_file, option):\n    uty.write_log(f\"Extract .csv\", FILENAME)\n    if not os.path.exists(folder):\n        print(f\"Error: The folder {folder} does not exist.\")\n        return\n    for filename in os.listdir(folder):\n        if filename.endswith(\".std\"):\n            cmd = f'\"{hex_file}\" \"{os.path.join(folder, filename)}\" {option}'\n            debug and print(cmd)\n            subprocess.run(cmd, shell=True)",
        "detail": "src.stdf2csv",
        "documentation": {}
    },
    {
        "label": "move_csv_files",
        "kind": 2,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "def move_csv_files(src_folder, dest_folder):\n    uty.write_log(f\"Move .csv\", FILENAME)\n    if not os.path.exists(src_folder):\n        print(f\"Error: The source folder {src_folder} does not exist.\")\n        return []\n    if not os.path.exists(dest_folder):\n        os.makedirs(dest_folder)\n    csv_name = \"\"\n    for filename in os.listdir(src_folder):\n        if filename.endswith(\".csv\"):",
        "detail": "src.stdf2csv",
        "documentation": {}
    },
    {
        "label": "get_folder_size",
        "kind": 2,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "def get_folder_size(folder):\n    total_size = 0\n    for dirpath, dirnames, filenames in os.walk(folder):\n        for f in filenames:\n            fp = os.path.join(dirpath, f)\n            total_size += os.path.getsize(fp)\n    return total_size\ndef delete_related_files(csv_folder, std_file_prefix):\n    uty.write_log(f\"MAX CAHCHE remove old .csv\", FILENAME)\n    related_files = [f for f in os.listdir(csv_folder) if f.startswith(std_file_prefix)]",
        "detail": "src.stdf2csv",
        "documentation": {}
    },
    {
        "label": "delete_related_files",
        "kind": 2,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "def delete_related_files(csv_folder, std_file_prefix):\n    uty.write_log(f\"MAX CAHCHE remove old .csv\", FILENAME)\n    related_files = [f for f in os.listdir(csv_folder) if f.startswith(std_file_prefix)]\n    for f in related_files:\n        os.remove(os.path.join(csv_folder, f))\ndef stdf2csv_converter(path_fin, path_fout, option=\"\"):\n    hex_file = os.path.abspath(\"src/STDF2CSV.exe\")\n    cmd = f'\"{hex_file}\" \"{os.path.join(path_fin)}\" -t'\n    debug and print(cmd)\n    subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL)",
        "detail": "src.stdf2csv",
        "documentation": {}
    },
    {
        "label": "stdf2csv_converter",
        "kind": 2,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "def stdf2csv_converter(path_fin, path_fout, option=\"\"):\n    hex_file = os.path.abspath(\"src/STDF2CSV.exe\")\n    cmd = f'\"{hex_file}\" \"{os.path.join(path_fin)}\" -t'\n    debug and print(cmd)\n    subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL)\n    cmd = f'\"{hex_file}\" \"{os.path.join(path_fin)}\" {option}'\n    debug and print(cmd)\n    subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL)\n    move_csv_files(os.path.dirname(path_fin), os.path.dirname(path_fout))\ndef stdf2csv(stdf_folders, csv_folder, option=\"\"):",
        "detail": "src.stdf2csv",
        "documentation": {}
    },
    {
        "label": "stdf2csv",
        "kind": 2,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "def stdf2csv(stdf_folders, csv_folder, option=\"\"):\n    # if  os.path.exists(csv_folder):\n    #     shutil.rmtree(csv_folder)\n    if not os.path.exists(csv_folder):\n        os.makedirs(csv_folder)\n    csv_name = []\n    for stdf_folder in stdf_folders:\n        rename_files(stdf_folder, \".stdf\", \".std\")\n        std_files = [f for f in os.listdir(stdf_folder) if f.endswith('.std')]\n        existing_csv_files = list(set(f[:-8] for f in os.listdir(csv_folder) if f.endswith('.csv')))",
        "detail": "src.stdf2csv",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 5,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "debug = False\nFILENAME = os.path.abspath(\"src/run.log\")\ndef rename_files(folder, old_ext, new_ext):\n    uty.write_log(f\"Rename .csv\", FILENAME)\n    if not os.path.exists(folder):\n        print(f\"Error: The folder {folder} does not exist.\")\n        return []\n    renamed_files = []\n    for filename in os.listdir(folder):\n        if filename.endswith(old_ext):",
        "detail": "src.stdf2csv",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "src.stdf2csv",
        "description": "src.stdf2csv",
        "peekOfCode": "FILENAME = os.path.abspath(\"src/run.log\")\ndef rename_files(folder, old_ext, new_ext):\n    uty.write_log(f\"Rename .csv\", FILENAME)\n    if not os.path.exists(folder):\n        print(f\"Error: The folder {folder} does not exist.\")\n        return []\n    renamed_files = []\n    for filename in os.listdir(folder):\n        if filename.endswith(old_ext):\n            base = os.path.splitext(filename)[0]",
        "detail": "src.stdf2csv",
        "documentation": {}
    }
]